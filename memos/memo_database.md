# database

## 用語

- 外部キー(foreign key)
  - 他のテーブルの関連行を指すための列

## 設計

- 設計手順
  - 要件定義
  - テーブル設計
    - 概念設計：管理する情報、情報同士の関連、要件をまとめる
    - 論理設計：テーブルとカラムを作成する（型とカラムはまだ）
    - 物理設計：特定のDBMS配下で型、インデックス、制約、デフォルト値を決定する
  - DDLをアウトプットとする
- 概念設計
  - 成果物
    - entityとattribute(属性)を明らかにしてER図にする
    - ER図は日本語であることが一般的
  - entity(=実在物)
    - 情報の塊(tableのようなもの)
    - attributeを持つ(カラムのようなもの)
    - entity同士の関連がある（リレーションのようなもの）
    - 書店の例
      - 書籍entity: タイトル、価格
      - 在庫entity: 書籍、数量
    - 導出手順
      - 候補となる用語＝名詞（人、もの、事実、行為）を洗い出す
      - 不要なものを捨てる：他の用語の具体例、計算できるもの
      - 関連がありそうなものをまとめる（本のタイトル、価格、著者）
      - entity名とattributeに分ける（AをしたB、AのBが成立するならAがentityでBがattribute）
  - ER図（entity-relation）
    - 記載物
      - entity, attributes, primary key, foreign key
      - 多重度: 0, 1, 0/1, n, n(>=0), n(>=1)
      - 補足例。部署-社員の場合、過去に存在して今は社員がいない部署も考慮
- 論理設計：ER図からrelational data modelにする
  - 目的
    - 概念スキーマを定義する設計
  - 設計手順
    - エンティティの抽出
    - エンティティの定義
      - どのようなデータ＝属性＝attribute=列を持つかを決める
    - 正規化
    - ER図の作成
  - 終了条件：システムに必要なテーブルと列を漏れなく明らかにする
  - アプローチ
    - トップダウン：ユーザーインタビュー、顧客要望からER図を作成する
    - ボトムアップ：既存のシステムを正規化してER図を作成する
    - 最終的に付き合わせる
  - トップダウン
    - 多対多を分解する
      - RDBでは多対多を表現できないため
      - 中間テーブル(関連entity)を追加して多対多を2つの多対多（一対多対一）にする
        - 2つのFKを持つテーブルとなる
    - キーの整理：適切な主キーを持たせる
  - ボトムアップ
    - 正規化
      - 矛盾や重複データがないようにテーブルを複数に分割する
      - 非正規系、第一正規系から第五正規形まであるが、通常は第三正規系までで十分
        - 正規化の手順に出てくる用語は難しいので、ざっくりきたない関数従属をなくすと覚えても良い
      - 非正規系：セルの結合、一つのセルに複数行が存在
      - テーブルにおける理想的な関数従属
        - すべての非キー列は主キーに正しく関数従属している
      - 第一正規系
        - 前提
          - 関数従属性
            - ある列Aの値が決まれば自ずとB列の値も決まる関係
            - このとき列Bは列Aに関数従属しているという
            - 列Aは主キーになる
          - 一つのセルに複数の値があると関数従属性を満たせない
        - 状態
          - 一つのセルに一つの値のみを含む
        - 手順
          - 繰り返している列を別表に切り出す（例。idとname）
          - 切り出したテーブルの仮の主キーを決める
          - 主キー列をコピーして複合主キーを構成する
        - 必要性
          - 主キーが各列の値を一意に決められるようになるため
            - 例.社員テーブルに子ども列がある場合
              - 二人の子どもを一つの列に入れると一意に子どもを特定できない
      - 第二正規系
        - 前提
          - 部分関数従属
            - 複合主キーのあるテーブルが対象
            - 非キー列が片側の主キーのみで関数従属している状態
        - 状態
          - 対象は複合主キーが存在するテーブル。なければ問題にならないので次へ
          - 部分関数従属がない＝すべての非キー列が「複合主キーの全体」に関数従属する
            - 部分関数従属（複合主キーのうちの一部分だけで値が決まる列）があるとNG
        - 手順
          - 部分関数従属している列を別テーブルに切り出す
          - 部分関数従属されていた列をコピーして主キーとする
            - （複合主キーではなく新たに人工主キーを追加しても必要になる）
          - 必要性
            - 部分関数従属している列を不正な値で更新できてしまう
            - 部分関数従属が存在すると異なるエンティティが含まれていることになる
      - 第三正規系
        - 前提
          - 推移関数従属
            - 主キーと直接関係なく、主キーと関数従属にあるべつの非キーと関数従属にあるもの
              - 例：書籍id, 著者id, 著者名 がある場合の著者名
          - 非キー列は主キーに直接関数従属するべき
        - 状態
          - 推移関数従属がない
        - 手順
          - 推移関数従属の列を別テーブルに切り出す
          - 切り出した列に従属されていた列をコピーする
          - 必要性
            - 例えば社員が今はたまたまいない会社名や部署名などをDBに登録できない
      - 正規化できたテーブルからER図を作成する
- 物理設計
  - 成果物
    - テーブル設計仕様書（ER図では表現できない仕様も含まれる）
      - 詳細
        - テーブル名とカラム名を決定。ここで英語化する
        - カラムの詳細決定：型、制約、デフォルト値
        - インデックスの決定：ユースケースを考慮する
    - DDL（テーブルを作成するSQL）
      - index、view、必要に応じてよく使うクエリも含める
  - 設計手順
    - テーブル定義：テーブル単位に変換
    - インデックス定義
    - ハードウェアサイジング：現在はクラウドの中で決める？
    - ストレージの冗長構成決定
    - ファイルの物理配置決定

## トランザクション

- 副作用
  - ダーティリード
    - コミット前の状態が読めてしまうこと
    - ROLLBACKすると他方が不正の状態でコミットする恐れがある
  - 反復不能読み取り（non-repeatable-read)
    - SELECTで探索、WHEREで更新する間に誰かがUPDATEして内容が変わること
  - ファントムリード（phantom read）
    - 2回のselect分の間に誰かがinsertして行数が変わること
- トランザクション分離レベル
  - 安全性と速度はバランス
  - レベル
    - UNREAD COMMITTED : dirty-read & non-repeatable-read & phantom-read
    - READ COMMITTED : non-repeatable-read & phantom-read
    - REPEATABLE READ : phantom-read
    - SERIALIZABLE : nothing
  - 大抵はREAD COMMITTEDが選ばれる
  - SQLから設定できる
  - コミット毎に設定できる
- ロック
  - 排他ロック(exclusive lock)
    - 他からのロックを許可しない
    - 主にデータ更新時に使用
  - 共有ロック(shared lock)
    - 他からの共有ロックを許容する
    - データの読み取りに使用
  - 行ロックの取得:SELECT FOR UPDATE(NO WAIT)
    - SELECT分の末尾にFOR UPDATEを追加すると排他ロックがかかる
    - 後からロックをかけた方は前者がcommitかROLLBACKで解除するまで待たされる
      - NO WAITオプションを待たずに即時失敗となる
  - 表ロックの取得：LOCK TABLE
  - デッドロック
    - RDBMSが監視しており他方を失敗させる
    - 回避策：処理時間を短くする、ロック順を揃える

## データ復旧

- 復旧方法
  - リストア：スナップショットを復元する
  - リカバリ：差分/増分のトランザクションを進める
  - ロールフォワード：DBに残っているトランザクションを進める
- 保存方法
  - フルバックアップ＝スナップショット
    - 丸ごとコピー
    - サービスを止めないと実行できない
  - 差分バックアップ
    - フルバックアップからの変更分を取る
      - トランザクションをコピーしている
  - 増分バックアップ
    - 前回の差分バックアップからの変更分を取る
- バックアップデータが壊れていると復旧できない
- 差分、増分と保存時の効率は良くなるが復旧時の工数は増える
