# database

## 用語

- 外部キー(foreign key)
  - 他のテーブルの関連行を指すための列

## 設計

- 設計手順
  - 要件定義
  - テーブル設計
    - 概念設計：管理する情報、情報同士の関連、要件をまとめる
    - 論理設計：テーブルとカラムを作成する（型とカラムはまだ）
    - 物理設計：特定のDBMS配下で型、インデックス、制約、デフォルト値を決定する
  - DDLをアウトプットとする
- 概念設計
  - 成果物
    - entityとattribute(属性)を明らかにしてER図にする
    - ER図は日本語であることが一般的
  - entity(=実在物)
    - 情報の塊(tableのようなもの)
    - attributeを持つ(カラムのようなもの)
    - entity同士の関連がある（リレーションのようなもの）
    - 書店の例
      - 書籍entity: タイトル、価格
      - 在庫entity: 書籍、数量
    - 導出手順
      - 候補となる用語＝名詞（人、もの、事実、行為）を洗い出す
      - 不要なものを捨てる：他の用語の具体例、計算できるもの
      - 関連がありそうなものをまとめる（本のタイトル、価格、著者）
      - entity名とattributeに分ける（AをしたB、AのBが成立するならAがentityでBがattribute）
  - ER図を作成する場合もある（entity-relation）
- 論理設計
  - 目的
    - 概念スキーマを定義する設計
  - 設計手順
    - エンティティの抽出
    - エンティティの定義
      - どのようなデータ＝属性＝attribute=列を持つかを決める
    - 正規化
    - ER図の作成
  - 終了条件：システムに必要なテーブルと列を漏れなく明らかにする
  - アプローチ
    - トップダウン：ユーザーインタビュー、顧客要望からER図を作成する
    - ボトムアップ：既存のシステムを正規化してER図を作成する
    - 最終的に付き合わせる
  - トップダウン
    - ER図（entity-relation）
      - 記載物
        - entity, attributes, primary key, foreign key
        - キー属性を上に、比キー属性を下に記載する
        - 多重度: 0, 1, 0/1, n, n(>=0), n(>=1)
      - 記載方法
        - IE：Information Engineering
          - 完結、鳥の足
        - IDEF1X(アイデフ　ワン　エックス)
          - 米空軍が発祥、米国規格化で詳細
          - NULLを許容する場合は白い菱形：◇
          - 実線と波線
            - 依存リレーションシップ：必ず属すのでnot null :実線
            - 非依存リレーションシップ：nullable:破線
          - 従属エンティティの場合は角を丸にする
            - 外部キーが主キーに入っていて、他のテーブルが先に決まらないと自分が決まらない状態
      - 補足
        - 主キーが他のテーブルに含まれているかに着目する＝多重度
        - 1対1はあまりない。一つのテーブルにまとめることができるから。
        - 部署-社員の場合、過去に存在して今は社員がいない部署も考慮するなら0以上、しないなら1以上
    - 多対多を分解する
      - 関連エンティティ、associative entityと呼ばれる
      - RDBでは多対多を表現できないため
      - 中間テーブル(関連entity)を追加して多対多を2つの多対多（一対多対一）にする
        - 2つのFKを持つテーブルとなる
    - キーの整理：適切な主キーを持たせる
  - ボトムアップ
    - 正規化
      - 矛盾や重複データがないようにテーブルを複数に分割する
      - 非正規系、第一正規系から第五正規形まであるが、通常は第三正規系までで十分
        - 正規化の手順に出てくる用語は難しいので、ざっくりきたない関数従属をなくすと覚えても良い
      - 非正規系：セルの結合、一つのセルに複数行が存在
      - テーブルにおける理想的な関数従属
        - すべての非キー列は主キーに正しく関数従属している
      - 第一正規系
        - 前提
          - 関数従属性
            - ある列Aの値が決まれば自ずとB列の値も決まる関係
            - このとき列Bは列Aに関数従属しているという
            - 列Aは主キーになる
          - 一つのセルに複数の値があると関数従属性を満たせない
        - 状態
          - 一つのセルに一つの値のみを含む
        - 手順
          - 繰り返している列を別表に切り出す（例。idとname）
          - 切り出したテーブルの仮の主キーを決める
          - 主キー列をコピーして複合主キーを構成する
        - 必要性
          - 主キーが各列の値を一意に決められるようになるため
            - 例.社員テーブルに子ども列がある場合
              - 二人の子どもを一つの列に入れると一意に子どもを特定できない
      - 第二正規系
        - 前提
          - 部分関数従属
            - 複合主キーのあるテーブルが対象
            - 非キー列が片側の主キーのみで関数従属している状態
        - 状態
          - 対象は複合主キーが存在するテーブル。なければ問題にならないので次へ
          - 部分関数従属がない＝すべての非キー列が「複合主キーの全体」に関数従属する
            - 部分関数従属（複合主キーのうちの一部分だけで値が決まる列）があるとNG
        - 手順
          - 部分関数従属している列を別テーブルに切り出す
          - 部分関数従属されていた列をコピーして主キーとする
            - （複合主キーではなく新たに人工主キーを追加しても必要になる）
          - 必要性
            - 部分関数従属している列を不正な値で更新できてしまう
            - 部分関数従属が存在すると異なるエンティティが含まれていることになる
      - 第三正規系
        - 前提
          - 推移関数従属
            - 主キーと直接関係なく、主キーと関数従属にあるべつの非キーと関数従属にあるもの
              - 例：書籍id, 著者id, 著者名 がある場合の著者名
          - 非キー列は主キーに直接関数従属するべき
        - 状態
          - 推移関数従属がない
        - 手順
          - 推移関数従属の列を別テーブルに切り出す
          - 切り出した列に従属されていた列をコピーする
          - 必要性
            - 例えば社員が今はたまたまいない会社名や部署名などをDBに登録できない
      - 正規化できたテーブルからER図を作成する
- 物理設計
  - 成果物
    - テーブル設計仕様書（ER図では表現できない仕様も含まれる）
      - 詳細
        - テーブル名とカラム名を決定。ここで英語化する
        - カラムの詳細決定：型、制約、デフォルト値
        - インデックスの決定：ユースケースを考慮する
    - DDL（テーブルを作成するSQL）
      - index、view、必要に応じてよく使うクエリも含める
  - 設計手順
    - テーブル定義：テーブル単位に変換
    - インデックス定義
    - ハードウェアサイジング：現在はクラウドの中で決める？
    - ストレージの冗長構成決定
    - ファイルの物理配置決定

## 正規化の欠点とパフォーマンス

- 正規化すると検索時のjoinが増える。joinは遅くなる
- 全ての値をupdateなどがあれば正規化の方が速い
- 検索SQLのパフォーマンスとデータ整合性のトレードオフ
- 対策方法はSQL文そのものに対するチューニング
- 非正規化は他のすべての戦略が要件を満たさない場合の最後の手段にする
- 遅延要因となるSQLの構文パターン
  - サマリデータの冗長性排除：集計値のカラムを持たせる
  - 選択条件の冗長性排除：検索用のカラムを追加する

## データベースとパフォーマンス

- パフォーマンスの主な要因はRAID
- SQLの結合（正規化）
- インデックスと統計

## インデックス

- 基本
  - アプリケーションコードに影響なし
  - テーブルデータに影響なし
  - 性能改善が大きい
    - 否定系については全操作が必要なので効果がない（B-treeの場合）
  - 内部的にソートが行われている処理がある
    - 集約系: count, sum, avg, max, min
    - ORDER BY, UNION系
    - ソートはコストが高いのでなるべく使わない方が良い
    - インデックスがあると改善される
  - 主キー、一意制約には自動的にインデックスが作成されるのでさらに作るのは不要
  - 複数行でも作成可能
  - インデックスは継ぎ足しで更新していくのでデータが増えると最適ではなくなってくる
    - コマンドで再構成（デフラグ）を行うことができる
  - 基本はB-tree系
    - 一般的でデフォルト
    - オール4の秀才系
    - B-treeのBの意味は不明
- 設計方針
  - 大規模なテーブルに作成する
    - データ行が1万行以下ではほぼ効果がない
  - カーディナリティの高い列に作成する
    - カーディナリティ：値の種類の多さ。たとえば性別なら男性、女性、不詳で3
    - 全体のカラムの5％以下に絞り込めるものにする
      - 絞り込みができていないと結局その後にフル検索するため
  - WHERE句の選択条件、JOINの結合条件に使用されている列に作成する
    - WHEREの効果がなくなるSQLの記載
      - index列に対して演算、関数を使用する場合
      - IS NULL, 否定系で検索している
      - ORを使用している→INで回避可能
      - 後方一致/中間一致のLIKEを使用している→前方一致のみ有効
      - 暗黙の型変換が行われる
  - B-tree以外のインデックス
    - ビットマップインデックス
      - データからビットデータを作成する
      - カーディナリティの低い列にも検索性能が良い、ORにも利用できる
      - テーブルのデータ更新時の性能が悪くなる
    - ハッシュインデックス
      - 値のハッシュを作成する
      - ＝に関しては一回の読み込みで目的のデータにアクセスできる
      - ＝以外では役に立たない

## 統計情報

- DBMSがSQLを受け取ってからテーブルにアクセスするための経路決定に使用する情報
- 開発者が関与するのは統計情報の更新タイミングの設定
- 性能面を考えると大きなテーブル変更のあった後に行うのが好ましい
- 負荷の面を考えると利用者が少ない時間帯を指定するのが好ましい

## 論理設計のノウハウ

- ビジネスロジックの実装
  - 主キー、制約などのRDBの基本的なルールはDBで実装する（これらの永続性は高いことが多い）
  - それ以外はアプリケーション側で実装する
- 配列型
  - サポートはされているが、広く使われてはいない
  - スカラ値ではなくなるので第一正規形から崩れてしまう
  - アプリケーションやミドルウェアとの整合性のコストが必要になる
  - 配列方は使わない方が良い
- スカラ値
  - 定義はシステム要件に依存する
  - 意味の取れる範囲で可能な限りに分解するのが良い
    - 名前は苗字と名前に分解、メールアドレスは@の前後で分解
  - 結合は容易だが分解は困難
- 列の名前変更
  - 列は変数ではない、事実を表している
  - 途中で名前を変えることは許されない
  - 列を追加するべき
- 水平分割
  - レコード単位で分割する。たとえば年度毎にテーブルを分割する
  - 動機：行数増加による性能劣化のため
  - デメリット：正規化の理論から外れる、拡張性と保守性が乏しい
  - 代替手段としてパーテーションが存在する
- 垂直分割
  - 列単位で分割する
  - 動機：SQLのデータアクセス数の削減による性能改善
  - デメリット：正規系が崩れる
  - 代替手段：集約
- 集約方法
  - データマート
    - 既存の列を残したまま新規にテーブルを追加する
  - サマリーテーブルの追加
    - 頻繁に行われる集計SQLの結果を別テーブルに書き出しておく
  - 共通するメリデメ
    - SQL実行速度の改善
    - データが不一致になる期間が存在するのでオリジナルとの同期方法が要検討
    - 多少ストレージの容量をつ合う
- キー、テーブルの結合条件で使われる列の型
  - 可変長文字列（VARCHAR）を使ってはいけない。名前使われることが多い。
  - 苗字、会社名、部署名は変更する可能性がある
  - 固定長文字列と同じ値にならないことが多い（空白の混入、数字の0パティング)
- キーで値を一意にたもてなくなったら？
  - たとえば使用できる範囲を使い切ってしまった
  - 代理キー(surrogate key)を導入する
    - 最初から存在するキーの代わりに新たにキーを追加する
    - このような人工キーではなくなるべき自然キー（エンティティとして存在するもの）を使用するべき
- ビュー
  - クエリの缶詰で単なるSQLを保存しているに過ぎない
  - 多段ビューでは複数回のSQLが実行されるので遅くなる
- データクレンジング
  - 元のデータは綺麗にしてからDB設計を行う
  - 人工キーの追加
  - 名寄せ

## トランザクション

- 副作用
  - ダーティリード
    - コミット前の状態が読めてしまうこと
    - ROLLBACKすると他方が不正の状態でコミットする恐れがある
  - 反復不能読み取り（non-repeatable-read)
    - SELECTで探索、WHEREで更新する間に誰かがUPDATEして内容が変わること
  - ファントムリード（phantom read）
    - 2回のselect分の間に誰かがinsertして行数が変わること
- トランザクション分離レベル
  - 安全性と速度はバランス
  - レベル
    - UNREAD COMMITTED : dirty-read & non-repeatable-read & phantom-read
    - READ COMMITTED : non-repeatable-read & phantom-read
    - REPEATABLE READ : phantom-read
    - SERIALIZABLE : nothing
  - 大抵はREAD COMMITTEDが選ばれる
  - SQLから設定できる
  - コミット毎に設定できる
- ロック
  - 排他ロック(exclusive lock)
    - 他からのロックを許可しない
    - 主にデータ更新時に使用
  - 共有ロック(shared lock)
    - 他からの共有ロックを許容する
    - データの読み取りに使用
  - 行ロックの取得:SELECT FOR UPDATE(NO WAIT)
    - SELECT分の末尾にFOR UPDATEを追加すると排他ロックがかかる
    - 後からロックをかけた方は前者がcommitかROLLBACKで解除するまで待たされる
      - NO WAITオプションを待たずに即時失敗となる
  - 表ロックの取得：LOCK TABLE
  - デッドロック
    - RDBMSが監視しており他方を失敗させる
    - 回避策：処理時間を短くする、ロック順を揃える

## データ復旧

- 復旧方法
  - リストア：スナップショットを復元する
  - リカバリ：差分/増分のトランザクションを進める
  - ロールフォワード：DBに残っているトランザクションを進める
- 保存方法
  - フルバックアップ＝スナップショット
    - 丸ごとコピー
    - サービスを止めないと実行できない
  - 差分バックアップ
    - フルバックアップからの変更分を取る
      - トランザクションをコピーしている
  - 増分バックアップ
    - 前回の差分バックアップからの変更分を取る
- バックアップデータが壊れていると復旧できない
- 差分、増分と保存時の効率は良くなるが復旧時の工数は増える
